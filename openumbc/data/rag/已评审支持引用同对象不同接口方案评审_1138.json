{
    "topic_id": 1138,
    "question": "【已评审】支持引用同对象不同接口方案评审 - content: 背景说明\n业务场景中频繁存在访问Chip方法的场景，且这些方法是挂在不同interface下面的，举例如下：\n\nCpld对象下的Read/Write方法在bmc.kepler.Chip.BlockIO接口下，SetLockStatus方法在bmc.kepler.Chip接口下\n\n{\n    \"Cpld\": {\n        \"package\":\"Cpld\",\n        \"path\": \"/bmc/kepler/Chip/Cpld/:Id\",\n        \"interfaces\": [\n            \"bmc.kepler.Chip.BlockIO\",\n            \"bmc.kepler.Chip\",\n            \"bmc.kepler.Chip.JtagTarget\",\n            \"bmc.kepler.Release.TraceChip\"\n        ]\n    }\n}\n\n{\n    \"bmc.kepler.Chip.BlockIO\": {\n        \"properties\": {},\n        \"methods\": {\n            \"Read\": {\n                \"req\": {\n                    \"Offset\": {\n                    },\n                    \"Length\": {\n                    }\n                },\n                \"rsp\": {\n                    \"OutData\": {\n                    }\n                },\n                \"description\": \"按字节读取从芯片的offset偏移位置读取指定长度内容\"\n            },\n            \"Write\": {\n                \"req\": {\n                    \"Offset\": {\n                    },\n                    \"InData\": {\n                    }\n                },\n                \"description\": \"按字节将指定内容写入芯片的offset偏移位置\"\n            }\n        }\n    }\n}\n\n{\n    \"bmc.kepler.Chip\": {\n        \"properties\": {\n            \"LockStatus\": {\n                \"description\": \"硬件通道锁定状态，0表示未锁定，1表示锁定\"\n            }\n        },\n        \"methods\": {\n            \"SetAccessibility\": {\n                \"req\": {\n                    \"Status\": {\n                    },\n                    \"DisableDuration\": {\n                    }\n                },\n                \"description\": \"设置芯片可访问状态: true:使能访问芯片， false:禁止访问芯片，禁止时长，单位: 秒，取值范围: [1, 1800]\"\n            },\n            \"SetLockStatus\": {\n                \"req\": {\n                    \"OpType\": {\n                    },\n                    \"LockTime\": {\n                    }\n                },\n                \"rsp\": {\n                    \"ResultCode\": {\n                    }\n                },\n                \"description\": \"设置芯片锁定状态，optype为1，表示加锁，0表示解释\"\n            }\n        }\n    }\n}\n\n详细描述\n针对以上场景，有如下两种实现方案：\n方案一（已有机制支持）\n通过refInterface语法配置接口引用，从而指明引用对象是在哪个接口下，有几个接口就配置几个属性承载；\n\n对应model.json配置样例如下：\n\n\"LogicFirmware\": {\n    \"properties\": {\n        \"UpgradeChip\": {\n            \"usage\": [\n                \"CSR\"\n            ],\n            \"baseType\": \"U8[]\",\n            \"refInterface\": \"bmc.kepler.Chip.BlockIO\"\n        },\n        \"UpgradeLockChip\": {\n            \"usage\": [\n                \"CSR\"\n            ],\n            \"baseType\": \"U8[]\",\n            \"refInterface\": \"bmc.kepler.Chip\"\n        }\n    }\n}\n\n对应CSR配置样例如下：\n\n\"LogicFirmware_SEU_1\": {\n    \"UpgradeChip\": \"#/Cpld_1\",\n    \"UpgradeLockChip\": \"#/Cpld_1\"\n}\n\n使用样例：\n\nlocal logic_fw_obj = xxx\n\nlogic_fw_obj.UpgradeChip:Write(xx)\nlogic_fw_obj.UpgradeLockChip:SetLockStatus(xx)\n\n方案优缺点：\n\n优点：属性已绑定对象接口，编码时通过属性名即可区分用途，不需要额外指定接口，理解和开发成本低；\n缺点：引用同一个对象的多个接口时，需要在模型中添加多个属性来绑定不同接口，并且需要在各产品所有对象的CSR配置中添加属性配置，配置和维护成本高；\n\n方案二（需要新增机制）\n新增MDS语法：通过refInterfaces语法配置引用多个接口，从而使用一个属性就可以承载多个接口下的对象，可以极大的减少CSR配置工作量和出错的风险；\n\n对应model.json配置样例如下：\n\n\"LogicFirmware\": {\n    \"properties\": {\n        \"UpgradeChip\": {\n            \"usage\": [\n                \"CSR\"\n            ],\n            \"baseType\": \"U8[]\",\n            \"refInterfaces\": [\n                \"bmc.kepler.Chip\",\n                \"bmc.kepler.Chip.BlockIO\"\n            ]\n        }\n    }\n}\n\n对应CSR配置样例如下：\n\n\"LogicFirmware_SEU_1\": {\n    \"UpgradeChip\": \"#/Cpld_1\"\n}\n\n使用样例：\n\nlocal logic_fw_obj = xxx\nlocal logic_upgrade_chip = logic_fw_obj.UpgradeChip[\"bmc.kepler.Chip.BlockIO\"]\nlocal logic_lock_chip = logic_fw_obj.UpgradeChip[\"bmc.kepler.Chip\"]\n\nlogic_upgrade_chip:Write(xx)\nlogic_lock_chip:SetLockStatus(xx)\n\n方案优缺点：\n\n优点：扩展友好，引用同一对象多个接口时，只需要在MDS模型中原有属性下添加新的接口即可，不需要新增属性，也不需要批量修改CSR配置，配置和维护成本低、验证工作量小；\n缺点：开发者在使用时，需要使用指定接口来调用方法或获取属性，开发者需要理解refInterface和refInterfaces的区别；\n\n评审点\n是否新增支持方案二，即新增refInterfaces关键字描述引用的接口列表，简化多接口引用的配置复杂度\n评审结论\n通过，具体结论如下：\n同意新增 refInterfaces关键字描述引用的接口列表，简化多接口引用的配置复杂度。需要补充约束：refInterfaces下挂interface必须是在相同path下，自动生成代码增加约束检查。\nlinks: #p-2459-h-1, #p-2459-h-2, #p-2459-h-3, #p-2459-h-4, #p-2459-h-5, #p-2459-h-6, #p-2459-h-7, #p-2459-h-8",
    "topic_user_name": "lixiaoning",
    "best_answer_url": "",
    "reply_posts": [
        {
            "user_name": "huanghan",
            "topic_closed": null,
            "is_solution": false,
            "post_url": "/t/topic/1138/2",
            "text": ""
        }
    ]
}