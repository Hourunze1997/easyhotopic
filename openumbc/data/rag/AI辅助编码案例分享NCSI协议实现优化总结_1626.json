{
    "topic_id": 1626,
    "question": "AI辅助编码案例分享：NCSI协议实现优化总结 - content: 本文将结合NCSI协议开发中的真实场景，介绍如何借助AI大模型提升协议栈开发与维护效率，并分享实用Prompt技巧与重构策略。\n一、项目背景与挑战\n1.1 NCSI协议简介\nNCSI（Network Controller Sideband Interface）是BMC与网络控制器之间的通信协议。随着项目迭代，代码量不断膨胀，重复逻辑严重，尤其体现在：\n\n模块代码重复：如通道管理、广播/多播过滤等模块，结构高度一致却需单独维护。\n测试用例冗余：相似测试模式反复手写，维护代价高。\n修改影响面广：日志格式、错误码改动需同步多个函数，易漏改。\n\n这些问题不仅影响研发效率，还阻碍了新功能的快速开发。\n1.2 重复模式分析\n1.2.1 命令处理函数\n重复特征（eg. 通道使能模块，多播过滤模块）\n\n参数模式：(package_id, channel_id, eth_name)\n处理逻辑：调用通用处理函数\n错误处理：相似的错误日志格式\n返回值：统一的返回码\n\n不同点\n\n报文结构不同，宏定义不同 → 但规律性重复性高，人工劳动繁琐\n\n-- 启用通道\nfunction ncsi_channel.ncsi_enable_channel(package_id, channel_id, eth_name)\n    local req_packet = fill_channel_req_packet(package_id, channel_id, ENABLE_CHANNEL)\n\n    local ret = ncsi_utils.ncsi_cmd_ctrl(package_id, channel_id, req_packet, eth_name, ncsi_channel_table)\n    if ret ~= ncsi_def.NCSI_SUCCESS then\n        log:error('ncsi cmd ctrl enable channel failed, package_id = %s, channel_id = %s, eth_name = %s',\n            package_id, channel_id, eth_name)\n    end\n    return ret\nend\n\n-- 禁用通道\nfunction ncsi_channel.ncsi_disable_channel(package_id, channel_id, eth_name)\n    local req_packet = fill_channel_req_packet(package_id, channel_id, DISABLE_CHANNEL)\n\n    local ret = ncsi_utils.ncsi_cmd_ctrl(package_id, channel_id, req_packet, eth_name, ncsi_channel_table)\n    if ret ~= ncsi_def.NCSI_SUCCESS then\n        log:error('ncsi cmd ctrl disable channel failed, package_id = %s, channel_id = %s, eth_name = %s',\n            package_id, channel_id, eth_name)\n    end\n    return ret\nend\n\n-- 命令类型常量定义\nlocal ENABLE_CHANNEL = 0x03\nlocal ENABLE_CHANNEL_RSP = 0x83\nlocal DISABLE_CHANNEL = 0x04\nlocal DISABLE_CHANNEL_RSP = 0x84\nlocal ENABLE_CHANNEL_TX = 0x06\nlocal ENABLE_CHANNEL_TX_RSP = 0x86\nlocal DISABLE_CHANNEL_TX = 0x07\nlocal DISABLE_CHANNEL_TX_RSP = 0x87\n\n-- 请求和响应长度\nlocal ENABLE_CHANNEL_REQ_LEN = 0\nlocal DISABLE_CHANNEL_REQ_LEN = 4\nlocal ENABLE_CHANNEL_TX_REQ_LEN = 0\nlocal DISABLE_CHANNEL_TX_REQ_LEN = 0\n-- 所有响应包长度相同\nlocal CHANNEL_RSP_LEN = 4\n\n-- 填充长度\nlocal ENABLE_CHANNEL_REQ_PAD_LEN = 26\nlocal DISABLE_CHANNEL_REQ_PAD_LEN = 22\nlocal ENABLE_CHANNEL_TX_REQ_PAD_LEN = 26\nlocal DISABLE_CHANNEL_TX_REQ_PAD_LEN = 26\n\n-- 请求和响应的位域结构定义\nlocal enable_channel_req_bs = bs.new([[<<\n    check_sum:32,\n    data:26/string,\n    fcs:32\n>>]])\n\nlocal disable_channel_req_bs = bs.new([[<<\n    allow_link_down:1,\n    reserved:31,\n    check_sum:32,\n    data:22/string,\n    fcs:32\n>>]])\n\n1.2.2 通用处理函数\n重复模式识别\n\n文件内部重复模式\n文件之间重复结构\n大量重复定义，人工对比提炼校验效率低\n\n隐含成本\n\n任何微小改动（如日志格式）都要同步多处\n\nfunction ncsi_packet.read_common_rsp(rsp, cmd_name)\n    if (rsp.packet_head.payload_len_lo | (rsp.packet_head.payload_len_hi << 8)) ~= COMMON_RSP_LEN then\n        log:error('Invalid %s response length', cmd_name)\n        return ncsi_def.NCSI_FAIL\n    end\n    local data = commom_rsp_bs:unpack(rsp.payload, true)\n    if not data then\n        log:error('Failed to unpack %s response payload', cmd_name)\n        return ncsi_def.NCSI_FAIL\n    end\n    local check_sum = data.check_sum\n    -- check_sum为0时不校验\n    if check_sum ~= 0 then\n        local tmp_check_sum = ncsi_utils.get_checksum(rsp, ncsi_def.PACKET_HEAD_LEN + COMMON_RSP_LEN)\n        if check_sum ~= core.htonl(tmp_check_sum) then\n            log:error('%s response checksum validation failed', cmd_name)\n            return ncsi_def.NCSI_FAIL\n        end\n    end\n    local rsp_code = data.rsp_code\n    if rsp_code == ncsi_def.CMD_COMPLETED then\n        return ncsi_def.NCSI_SUCCESS\n    end\n\n    ncsi_utils.common_respcode_parse(rsp_code)\n    ncsi_utils.common_reasoncode_parse(data.reason_code)\n    return ncsi_def.NCSI_FAIL\nend\n\n-- 通用通道处理函数\nlocal function handle_channel_operation(package_id, channel_id, eth_name, command_type, operation_name)\n    local req_packet = ncsi_packet.create_request_packet(package_id, channel_id, command_type)\n    local ret = ncsi_utils.ncsi_cmd_ctrl(package_id, channel_id, req_packet, eth_name, ncsi_channel_table)\n    if ret ~= ncsi_def.NCSI_SUCCESS then\n        log:error('ncsi cmd ctrl %s failed, package_id = %s, channel_id = %s, eth_name = %s',\n            operation_name, package_id, channel_id, eth_name)\n    end\n    return ret\nend\n\n1.2.3 测试用例\n-- 模拟发送NCSI命令的函数\nlocal function mock_send_ncsi_cmd(req_data, len, eth_name)\n\n-- 初始化函数，在每个测试用例前执行\nfunction TestNCSIChannel:setUp()\n    -- 保存原始函数\n    -- 使用模拟函数替换原始函数\n    -- 模拟NCSI参数\n    -- 模拟cmd_ctrl函数以便测试\n\n-- 清理函数，在每个测试用例后执行\nfunction TestNCSIChannel:tearDown()\n    -- 恢复原始函数\n\n-- 测试启用通道功能\nfunction TestNCSIChannel:test_enable_channel()\n    -- 测试参数\n    local package_id = 0\n    local channel_id = 1\n    local eth_name = \"eth0\"\n\n    -- 执行测试\n    local result = ncsi_channel.ncsi_enable_channel(package_id, channel_id, eth_name)\n\n    -- 验证结果\n    lu.assertEquals(result, ncsi_def.NCSI_SUCCESS)\n    lu.assertNotNil(self.last_req_data)\n    lu.assertEquals(self.last_eth_name, eth_name)\n\n    -- 测试不同的channel_id\n    self.last_req_data = nil\n    result = ncsi_channel.ncsi_enable_channel(package_id, 2, eth_name)\n    lu.assertEquals(result, ncsi_def.NCSI_SUCCESS)\n    lu.assertNotNil(self.last_req_data)\nend\n\n二、AI辅助编码策略及prompt编写\n2.1 代码生成\n\n合理编辑prompt，快速生成90%基础代码，人工仅需调整报文结构差异\n\n模板1: 基于现有模式生成新函数\n请基于以下现有代码模式，为新的NCSI命令 [COMMAND_NAME] 生成相应的函数：\n参考的头文件定义：\n命令类型宏定义：参考 test-main/ncsi 路径下头文件中的命令常量\n包结构定义：参考头文件中的请求/响应结构体定义\n长度宏定义：参考头文件中的 *_REQ_LEN、*_RSP_LEN、*_PAD_LEN 等宏\n现有模式：\nfunction ncsi_cmd.ncsi_enable_channel(package_id, channel_id, eth_name)\n要求：\n1. 函数名为 ncsi_[COMMAND_NAME]\n2. 参数为 package_id, channel_id, eth_name\n3. 包含相同的参数验证逻辑\n4. 调用对应的模块函数\n5. 返回相同的错误码\n请生成完整的函数代码。\n\n测试用例同理\n\n模板2: 测试用例生成Prompt\n请基于以下测试模式，为 [MODULE_NAME] 模块生成完整的测试用例：\n现有测试模式：\nfunction TestNCSIBroadcastFilter:test_enable_broadcast_filter()\n要求：\n1. 为 [MODULE_NAME] 创建测试类 TestNCSI[MODULE_NAME]\n2. 包含 setUp 和 tearDown 方法\n3. 为每个公共函数生成测试用例\n4. 包含成功和失败场景测试\n5. 验证请求报文格式\n6. 包含边界条件测试\n请生成完整的测试文件。\n\n2.2 代码重构\n2.2.1 Prompt示例\n模板3: 代码重构Prompt\n请分析以下重复代码模式，并提供重构建议：\n重复代码：\n[重复代码片段1]\n[重复代码片段2]\n[重复代码片段3]\n要求：\n1. 识别重复模式\n2. 提取公共函数\n3. 使用设计模式优化\n4. 保持向后兼容\n5. 提供重构后的代码\n请提供详细的重构方案和代码实现。\n\neg. 代码优化建议\n分析 src/lualib/ncsi/ncsi_protocol/ 目录下的代码，\n识别可以进一步优化的重复模式：\n\n当前已优化的模式：\n1. 使用 handle_channel_operation 通用函数\n2. 使用 ncsi_utils.create_custom_cmd_table\n3. 使用命令表模式\n\n请分析还有哪些重复代码可以进一步优化，\n并提供具体的优化方案和代码实现。\n\n2.2.2 优化结果\n\n通用处理函数\n\n-- 重构前：各模块独立实现\nfunction enable_channel(...)\n  -- 重复验证逻辑\n  -- 重复日志格式\nend\n\n-- 重构后：集中处理\nfunction handle_channel_operation(cmd, ...)\n  -- 统一验证/日志/错误处理\n  cmd.handler(...) -- 注入差异化逻辑\nend\n\n命令表模式-偏函数应用优化\n\n-- 在 ncsi_utils.lua 中定义\nlocal cmd_table = {\n  enable_broadcast = {\n    handler = broadcast_handler,\n    req_len = BROADCAST_REQ_LEN\n  },\n  -- ...其他命令\n}\n\nfunction create_command(cmd_name)\n  return function(...)\n    local cmd = cmd_table[cmd_name]\n    return handle_operation(cmd.handler, cmd.req_len, ...)\n  end\nend\n\n-- 创建自定义命令处理表\nfunction ncsi_utils.create_custom_cmd_table(base_cmd_table, cmd_type, write_func, ...)\n    local params = {...}\n\n    -- 直接在函数内复制表\n    local custom_cmd_table = {}\n    for k, v in pairs(base_cmd_table) do\n        custom_cmd_table[k] = v\n    end\n\n    custom_cmd_table[cmd_type] = function(req, eth)\n        if #params == 0 then\n            return write_func(req, eth)\n        else\n            return write_func(req, eth, table.unpack(params))\n        end\n    end\n\n    return custom_cmd_table\nend\n\n-- 创建自定义响应处理表\nfunction ncsi_utils.create_custom_rsp_table(base_cmd_table, cmd_rsp_type, read_func, ...)\n    local params = {...}\n\n    -- 直接在函数内复制表\n    local custom_cmd_table = {}\n    for k, v in pairs(base_cmd_table) do\n        custom_cmd_table[k] = v\n    end\n\n    custom_cmd_table[cmd_rsp_type] = function(rsp)\n        if #params == 0 then\n            return read_func(rsp)\n        else\n            return read_func(rsp, table.unpack(params))\n        end\n    end\n\n    return custom_cmd_table\nend\n\n代码复用率提升70%，新增命令只需注册到命令表\n三、有效Prompt编写技巧\n\n技巧\n低效示例\n高效示例\n\n明确角色与语气设定\n“帮我看看代码”\n“你是一个资深 Lua 开发工程师，请审查以下函数，指出优化点并重构代码”\n\n分步引导（Chain-of-Thought）\n“重构这段代码”\n“1. 分析重复模式 2. 提取公共函数 3. 给出重构代码”\n\nFew-shot示例\n“写个测试用例”\n“参考TestNCSIBroadcastFilter，为multicast_filter生成含边界测试的LuaUnit用例”\n\n强行动词 + Power Words\n“优化这个函数”\n“Refactor the following function to be concise and maintainable”\n\n四、当前主流AI模型\n推荐工具矩阵\n\n场景\n推荐工具\n\n快速原型\nGPT-4.5 / Claude 4\n\n本地隐私部署\nDeepSeek-R1 / LLaMA 4\n\n跨文件语义理解\nCursor\n\nCursor 实战亮点\n\n全项目级理解：直接提问“ ncsi_utils.lua 中哪个函数被 broadcast_filter 调用？”\n自然语言重构：输入“将此函数重命名并加入错误日志”，自动执行\n企业合规：隐私模式禁用数据上传\n将外部文档作为知识库进行问答\n可以加入内置System prompt\n\n五、效果评估与总结\nAI不是替代开发者，而是将人力从重复劳动中释放，聚焦架构设计与核心逻辑。\n除此之外还需要进行一系列检查，以保证代码质量：\n\n人工审查: AI生成的代码需要人工审查\n功能测试: 确保生成代码的功能正确性\n性能测试: 验证优化后的性能表现\n兼容性测试: 确保与现有系统的兼容性\nlinks: #p-3945-h-1, #p-3945-h-11-ncsi-2, #p-3945-h-12-3, #p-3945-h-121-4, #p-3945-h-122-5, #p-3945-h-123-6, #p-3945-aiprompt-7, #p-3945-h-21-8, #p-3945-h-22-9, #p-3945-h-221-prompt-10, #p-3945-h-222-11, #p-3945-prompt-12, #p-3945-ai-13, #p-3945-h-14, #p-3945-cursor-15, #p-3945-h-16",
    "topic_user_name": "Qian Yufei",
    "best_answer_url": "",
    "reply_posts": []
}