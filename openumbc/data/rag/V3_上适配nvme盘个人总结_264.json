{
    "topic_id": 264,
    "question": "V3 上适配nvme盘个人总结 - 1. 加载流程\nBMC首先会加载NVMe背板的Connector，命名上会包含背板的UID，在BusinessConnector下有RefMgmtConnector，背板会加载Connector_ComVPDConnect对象 Connector_ComVPDConnect对象中有\"Bom\": “14140224”、“Id”: “VPD\"以及\"AuxId”: “0” 框架会根据Bom、Id和AuxId进一步加载14140244_VPD_0. sr文件。例如Connector_ComVPDConnect_1在位是通过Scanner_Drive1PCIePresence和Scanner_Drive1PCIeType共同决定，在openubmc目录下展示了这两个值的来源于Smc_EnclSMC chip的读取\n\"Scanner_Drive1PCIePresence\": {\n      \"Chip\": \"#/Smc_EnclSMC\",\n      \"Offset\": 335545601,\n      \"Size\": 2,\n      \"Mask\": 1,\n      \"Type\": 0,\n      \"Period\": 2000,\n      \"Debounce\": \"None\",\n      \"Value\": 0\n    },\n    \"Scanner_Drive1PCIeType\": {\n      \"Chip\": \"#/Smc_EnclSMC\",\n      \"Offset\": 335545601,\n      \"Size\": 2,\n      \"Mask\": 2,\n      \"Type\": 0,\n      \"Period\": 2000,\n      \"Debounce\": \"None\",\n      \"Value\": 0\n    },\n\n在14140224_VPD_0.sr中，这里面有VirtualVPDConnect；在RefConnector中有定义对应的Connector_ComVPD，对应lua中c_vpd_connect\n---@class c_vpd_connect: c_object\n---@field Slot integer\n---@field RefVPDChip c_object\n---@field RefConnector c_object\nlocal c_vpd_connect = c_object('VirtualVPDConnect') -- VirtualVPDConnect类\n\n在Connector_ComVPD有Bom、Id、AuxId；AuxId对应的是nvme盘所支持的协议，在更新Connector的时候会重新确认当前盘支持哪种协议，然后更新当前的AuxId\nfunction c_vpd_connect:update_connector()\n    if not self.RefConnector then\n        return\n    end\n    local ok, aux_id = pcall(function()\n        return self:verify_vpd_protocol()\n    end)\n\n    log:notice('connector get protocol is %s', aux_id)\n    self.RefConnector.AuxId = ok and tostring(aux_id) or '255'\n\n    -- 确保AuxId比Presence先更新\n    while ok do\n        if self.RefConnector.AuxId == tostring(aux_id) then\n            self.RefConnector.Presence = 1\n            break\n        end\n        -- 避免长时间占用阻塞协程切换\n        skynet.sleep(100)\n    end\nend\n\n更新完以后，框架进一步加载Bom + Id +AuxId组合sr文件；例如支持nvme-mi协议，则加载14140224_PROTOCOL_0.sr；在14140224_PROTOCOL_0.sr中有对应的nvme对象；对应nvme_object.lua中的c_nvme\n---@class c_nvme: c_object\n---@field Slot integer\n---@field PredictedMediaLifeLeftPercent integer\n---@field Revision string\n---@field MediaType integer\n---@field Protocol integer\n---@field Failure integer\n---@field PredictiveFailure integer\n---@field TemperatureCelsius integer\n---@field VPDChip c_object\n---@field SSDChip c_object\n---@field RefComponent c_object\nlocal c_nvme = c_object('Nvme') -- Nvme 类，主键是 Slot 字段\n\n在14140224_PROTOCOL_0.sr中定义的三种Chip；分别是Chip_Virtual_SSD（VPDChip）、Chip_SSD和Chip_Temp；分别对应nvme盘产品规格书上的8位地址；根据厂商给出Data sheet偏移，读取nvme相应属性。\n2. 散热\nNvme盘目标调速由14140224_PROTOCOL_0.sr中的CoolingRequirement实现，曲线调速由CoolingPolicy实现\n目标调速\n\"CoolingRequirement_1_60\": {\n\"RequirementId\": \"${Slot} |> expr((60 << 8) | $1)\",\n    \"MonitoringStatus\": \"<=/Scanner_Temp.Value |> expr($1 >= 255 ? 1 : 0)\",\n    \"MonitoringValue\": \"<=/Scanner_Temp.Value\",\n    \"FailedValue\": 80,\n    \"TargetTemperatureCelsius\": 69,\n    \"MaxAllowedTemperatureCelsius\": 75,\n    \"TargetTemperatureRangeCelsius\": [],\n    \"ThresholdValue\": [],\n\"AlarmSpeed\": []\n}\n\nRequirementId：全局唯一，建议使用槽位号等能确保多次分发sr都是唯一值的属性；如果存在id相同，则后配置的CoolingRequirement无法调速\nMonitoringStatus：温度状态，用于异常调速，0正常其他值异常；当为异常值时，会使用FailedValue温度值进行异常调速\nMonitoringValue：温度值，关联硬件，不允许关联传感器reading值\nTargetTemperatureCelsius：目标调速值，默认模式是节能模式；如果涉及三种模式调速（节能模式、高性能模式、低噪音模式），SmartCoolingTargetTemperature可进行三种模式目标温度调速\nMaxAllowedTemperatureCelsius：目标调速满转温度\n环温曲线调速\n\"CoolingPolicy_1_15\": {\n\"PolicyIdx\": 15,\n    \"ExpCondVal\": \"EnergySaving\",\n    \"ActualCondVal\": \"<=/CoolingConfig_1.SmartCoolingMode\",\n    \"Hysteresis\": 1,\n    \"TemperatureRangeLow\": [-127,20,21,22,],\n    \"TemperatureRangeHigh\": [20,21,22,127],\n    \"SpeedRangeLow\": [20,30,50,100],\n    \"SpeedRangeHigh\": [20,30,50,100],\n    \"FanType\": [\"02314EWC 8080+\",\"02314BLG 8038+\"],\n    \"HDDBackPlaneName\": [\n        \"BC83HBBA\"\n     ]\n },\n\nPolicyIdx：Id全局唯一\nExpCondVal：期望条件，CoolingPolicy生效前提是实际条件与期望条件一致\nActualCondVal：实际条件\nHysteresis：迟滞量\nTemperatureRangeLow：环温调速曲线，同V2\nTemperatureRangeHigh：环温调速曲线，同V2\nSpeedRangeLow：环温调速曲线，同V2\nSpeedRangeHigh:环温调速曲线，同V2\nFanType：风扇类型，满足其中之一生效\nHDDBackPlaneName：硬盘背板名称，环境有该背板之一时生效\n调速分区\nCoolingArea用于关联CoolingPolicy和CoolingRequirement等调速，用于一个温度点调速需要哪些风扇，也说明一个温度点关联哪些环温曲线；一般来说CoolingArea与\nCoolingRequirement一一对应\n\"CoolingArea_1_6\": {\n \t\"AreaId\": 6,\n    \"RequirementIdx\": 6,\n    \"PolicyIdxGroup\": [6,20,25,30,34,40],\n    \"FanIdxGroup\": [1,2,3,4]\n},\n\nAreaId：Id全局唯一\nRequirementIdx：关联温度点，一般与CoolingRequirement的RequirementId关联\nPolicyIdxGroup：关联温度点，一般与环温调速CoolingPolicy的PolicyIdx关联\nFanIdxGroup：温度点关联风扇id，必须是整数，从小到大排序\n3. 基线\n适配基线主要包含：北向接口资产信息的获取，一般重要的属性包含健康状态、厂商、型号、序列号、固件版本、温度、容量以及剩余磨损率等。\n其他项：nvme盘告警事件包含VPDChip读取失败、固件版本读取失败、高温告警事件、温度获取失败事件等，具体可以参考14140224_PROTOCOL_0.sr\n4. 遇到问题\n当时适配大普盘时，BMC Web无法获取nvme盘的温度和固件版本等属性信息，经走读代码，初步判断代码所用Chip和偏移位并未配错，同步在BMC后台是mdbctl读取固件版本时出现链路不通。\n% call Chip_SSD_01010C0103 bmc.kepler.Chip.BlockIO Read 0 0x0b 8\nkepler.hwproxy.IOError: table: 0xffff287f1200\n\n同步对比V2配置的SSD Chip类对象，偏移位与V3配置相同；发现V2上能正常读取\n% testchip ssdChip-d02 0 1 0x0b 20\n0x52 0x53 0x36 0x55 0x30 0x31 0x41 0x32 0x34 0x43 0x30 0x31 0x48 0x53 0x43 0x30 0x20 0x20 0x20 0x20\n\n所用华为5.5版本非稳定版本，该Chip链路未正常配置，华为工程师沟通，温度和固件版本获取与上电状态有关；华为硬件怀疑CPLD版本过旧可能导致Chip通信失败，尝试更新Nvme背板CPLD后，Chip通信成功\n% call Chip_SSD_01010C0403 bmc.kepler.Chip.BlockIO Read 0 11 20\n[83,72,50,53,48,49,48,54,55,57,54,32,32,32,32,32,32,32,32,32]\n\n注：Chip是通过I2C/Smbus通信，线路是Nvme背板CPLD映射的虚拟线路，像nvme定位灯功能是通过向nvme背板发送SMC命令实现",
    "topic_user_name": "长江_赵凯",
    "best_answer_url": "",
    "reply_posts": []
}